from core.logging_utils import log_json
from core.file_tools import _safe_apply_change, Path, OldCodeNotFoundError, FileToolsError

class MutatorAgent:
    """
    The MutatorAgent is responsible for applying changes to the codebase based on
    mutation proposals, typically generated by the EvolutionLoop. It handles
    adding new files or replacing content within existing files, with robust
    path validation to ensure operations are confined to the project root.
    """
    def __init__(self, project_root: Path):
        """
        Initializes the MutatorAgent.

        Args:
            project_root (Path): The root directory of the project, used for path validation.
        """
        self.project_root = project_root
        log_json("INFO", "mutator_agent_initialized")

    def _validate_file_path(self, file_path: str) -> Path:
        """
        Validates a file path to ensure it is relative, does not contain path traversal,
        and is within the project_root. Returns the absolute Path object if valid.
        Raises ValueError if the path is invalid.
        """
        path_obj = Path(file_path)

        # 1. Ensure path is relative and does not start with '/' or Windows drive letters
        if path_obj.is_absolute():
            raise ValueError(f"Absolute paths are not allowed: {file_path}")

        # 2. Prevent path traversal (e.g., '..')
        if '..' in path_obj.parts:
            raise ValueError(f"Path traversal ('..') is not allowed: {file_path}")
        
        # 3. Resolve path and ensure it's within project_root
        resolved_path = (self.project_root / path_obj).resolve()
        if not resolved_path.is_relative_to(self.project_root.resolve()):
            raise ValueError(f"Path '{file_path}' resolves outside the project root.")

        return resolved_path

        def apply_mutation(self, mutation_proposal: str):

            """

            Applies one or more mutations to the codebase based on the `mutation_proposal`.

            The proposal is parsed for multiple commands (ADD_FILE or REPLACE_IN_FILE).

            Path validation is performed for every operation.

    

            Args:

                mutation_proposal (str): A string detailing the mutations to apply.

            """

            log_json("INFO", "mutator_applying_mutation", details={"proposal_snippet": mutation_proposal[:200]})

    

            # Split into blocks based on command keywords at start of lines

            # Using a regex to find commands that are followed by a space and are at the start of a line

            blocks = re.split(r'^(?=ADD_FILE|REPLACE_IN_FILE)', mutation_proposal, flags=re.MULTILINE)

            

            for block in blocks:

                block = block.strip()

                if not block:

                    continue

    

                lines = block.split('\n')

                command_line = lines[0].strip()

    

                if command_line.startswith("ADD_FILE"):

                    self._handle_add_file(command_line, lines[1:])

                elif command_line.startswith("REPLACE_IN_FILE"):

                    self._handle_replace_in_file(command_line, lines[1:], block)

                else:

                    log_json("WARN", "mutator_skipping_unrecognized_block", details={"command_line": command_line})

            

            log_json("INFO", "mutator_application_attempt_complete")

    

        def _handle_add_file(self, command_line: str, content_lines: list):

            try:

                parts = command_line.split(' ', 1)

                if len(parts) < 2:

                    log_json("ERROR", "mutator_add_file_missing_filepath", details={"command_line": command_line})

                    return

                file_path = parts[1].strip()

                content = "\n".join(content_lines)

                

                validated_file_path = self._validate_file_path(file_path)

                _safe_apply_change(self.project_root, str(validated_file_path.relative_to(self.project_root)), "", content, overwrite_file=True)

                log_json("INFO", "mutator_add_file_success", details={"file_path": str(validated_file_path.relative_to(self.project_root)), "content_length": len(content)})

            except Exception as e:

                log_json("ERROR", "mutator_add_file_failed", details={"error": str(e), "command": command_line})

    

        def _handle_replace_in_file(self, command_line: str, lines: list, full_block: str):

            try:

                # Expected format variations:

                # 1. REPLACE_IN_FILE <filepath>\n---OLD_CONTENT_START---...

                # 2. REPLACE_IN_FILE\n<filepath>\n---OLD_CONTENT_START---...

                

                parts = command_line.split(' ', 1)

                if len(parts) >= 2:

                    file_path = parts[1].strip()

                    content_start_idx = 0

                else:

                    if not lines:

                        log_json("ERROR", "mutator_replace_in_file_empty", details={"command": command_line})

                        return

                    file_path = lines[0].strip()

                    content_start_idx = 1

    

                old_content_start_marker = "---OLD_CONTENT_START---"

                old_content_end_marker = "---OLD_CONTENT_END---"

                new_content_start_marker = "---NEW_CONTENT_START---"

                new_content_end_marker = "---NEW_CONTENT_END---"

    

                try:

                    # Find indices within the remaining lines

                    # Note: We use the list 'lines' starting from content_start_idx

                    search_lines = lines[content_start_idx:]

                    old_start_idx = search_lines.index(old_content_start_marker)

                    old_end_idx = search_lines.index(old_content_end_marker, old_start_idx + 1)

                    new_start_idx = search_lines.index(new_content_start_marker, old_end_idx + 1)

                    new_end_idx = search_lines.index(new_content_end_marker, new_start_idx + 1)

                except ValueError:

                    log_json("ERROR", "mutator_replace_in_file_format_error", details={"file_path": file_path, "block_snippet": full_block[:200]})

                    return

    

                old_string = "\n".join(search_lines[old_start_idx + 1 : old_end_idx])

                new_string = "\n".join(search_lines[new_start_idx + 1 : new_end_idx])

    

                validated_file_path = self._validate_file_path(file_path)

                _safe_apply_change(self.project_root, str(validated_file_path.relative_to(self.project_root)), old_string, new_string)

                log_json("INFO", "mutator_replace_in_file_success", details={"file_path": str(validated_file_path.relative_to(self.project_root))})

            except Exception as e:

                log_json("ERROR", "mutator_replace_in_file_failed", details={"error": str(e), "file": file_path if 'file_path' in locals() else 'N/A'})

    